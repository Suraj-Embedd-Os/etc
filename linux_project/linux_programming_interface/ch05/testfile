As stated before, most Unix kernels are monolithic: each kernel layer is integrated
into the whole kernel program and runs in Kernel Mode on behalf of the current
process. In contrast, microkernel operating systems demand a very small set of
functions from the kernel, generally including a few synchronization primitives, a
simple scheduler, and an interprocess communication mechanism. Several system
processes that run on top of the microkernel implement other operating system-
layer functions, like memory allocators, device drivers, and system call handlers.
Although academic research on operating systems is oriented toward microkernels ,
such operating systems are generally slower than monolithic ones, because the
explicit message passing between the different layers of the operating system has a
cost. However, microkernel operating systems might have some theoretical
advantages over monolithic ones. Microkernels force the system programmers to
adopt a modularized approach, because each operating system layer is a relatively
independent program that must interact with the other layers through well-defined
and clean software interfaces. Moreover, an existing microkernel operating system
can be easily ported to other architectures fairly easily, because all hardware-
dependent components are generally encapsulated in the microkernel code. Finally,
microkernel operating systems tend to make better use of random access memory
(RAM) than monolithic ones, because system processes that aren't implementing
needed functionalities might be swapped out or destroyed.
To achieve many of the theoretical advantages of microkernels without introducing
performance penalties, the Linux kernel offers modules . A module is an object file
whose code can be linked to (and unlinked from) the kernel at runtime. The object
code usually consists of a set of functions that implements a filesystem, a device
driver, or other features at the kernel's upper layer. The module, unlike the external
layers of microkernel operating systems, does not run as a specific process. Instead,
it is executed in Kernel Mode on behalf of the current process, like any other
statically linked kernel function.
The main advantages of using modules include:
modularized approach
As stated before, most Unix kernels are monolithic: each kernel layer is integrated
into the whole kernel program and runs in Kernel Mode on behalf of the current
process. In contrast, microkernel operating systems demand a very small set of
functions from the kernel, generally including a few synchronization primitives, a
simple scheduler, and an interprocess communication mechanism. Several system
processes that run on top of the microkernel implement other operating system-
layer functions, like memory allocators, device drivers, and system call handlers.
Although academic research on operating systems is oriented toward microkernels ,
such operating systems are generally slower than monolithic ones, because the
explicit message passing between the different layers of the operating system has a
cost. However, microkernel operating systems might have some theoretical
advantages over monolithic ones. Microkernels force the system programmers to
adopt a modularized approach, because each operating system layer is a relatively
independent program that must interact with the other layers through well-defined
and clean software interfaces. Moreover, an existing microkernel operating system
can be easily ported to other architectures fairly easily, because all hardware-
dependent components are generally encapsulated in the microkernel code. Finally,
microkernel operating systems tend to make better use of random access memory
(RAM) than monolithic ones, because system processes that aren't implementing
needed functionalities might be swapped out or destroyed.
To achieve many of the theoretical advantages of microkernels without introducing
performance penalties, the Linux kernel offers modules . A module is an object file
whose code can be linked to (and unlinked from) the kernel at runtime. The object
code usually consists of a set of functions that implements a filesystem, a device
driver, or other features at the kernel's upper layer. The module, unlike the external
layers of microkernel operating systems, does not run as a specific process. Instead,
it is executed in Kernel Mode on behalf of the current process, like any other
statically linked kernel function.
The main advantages of using modules include:
modularized approach
